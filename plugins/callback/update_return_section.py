# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)

import collections
from pathlib import Path

import re
import yaml


from ansible.plugins.callback import CallbackBase


DOCUMENTATION = """
callback: update_return_section
"""

START_LINE_re = r"^RETURN\s=\s(r|)(\"{3}|\'{3})$"

def load_return_block(module_path):
    in_return_block = ''
    in_sub_block = False
    return_block = collections.defaultdict(list)
    for l in module_path.read_text().split("\n"):
        if not in_return_block and re.match(START_LINE_re, l):
            in_return_block = re.match(START_LINE_re, l).group(2)
        elif in_return_block and l == in_return_block:
            in_return_block = '' 
            break
        # NOTE: we don't really use this part 
        elif in_return_block and l.startswith("# task: "):
            in_sub_block = l.replace("# task: ", "")
        elif in_return_block and in_sub_block:
            return_block[in_sub_block].append(l)
    return return_block


def write_return_block(module_path, return_block):
    new_content = ""
    in_return_block = ""
    for l in module_path.read_text().split("\n"):
        if not in_return_block and re.match(START_LINE_re, l):
            in_return_block = re.match(START_LINE_re, l).group(2)
            new_content += l + "\n"
            for k, b in return_block.items():
                new_content += "# content generated by the update_return_section callback"
                new_content += "# task: " + k + "\n"
                new_content += "\n".join(b)
        elif in_return_block and l == in_return_block:
            in_return_block = ""
            new_content += l + "\n"
        elif in_return_block:
            continue
        else:
            new_content += l + "\n"
    module_path.write_text(new_content.rstrip("\n") + "\n")


def ansible_unsafe_to_python(data):
    if isinstance(data, int):
        return int(data)
    elif isinstance(data, str):
        return str(data)
    elif isinstance(data, list):
        return [ansible_unsafe_to_python(i) for i in data]
    elif isinstance(data, dict):
        return {
            ansible_unsafe_to_python(k): ansible_unsafe_to_python(i)
            for k, i in data.items()
        }


class CallbackModule(CallbackBase):
    CALLBACK_VERSION = 2.0
    CALLBACK_TYPE = "aggregate"
    CALLBACK_NAME = "goneri.utils.update_return_section"
    CALLBACK_NEEDS_WHITELIST = True

    def __init__(self, *args, **kwargs):
        super(CallbackModule, self).__init__(*args, **kwargs)
        self.task = None
        self.play = None

    def v2_runner_on_ok(self, result):
        r = result._result
        t = result._task

        value = r.get("value")
        if not value:
            return

        if t.name.startswith("_"):
            return

        if not t.name:
            return

        collection_root_dir = (
            Path.home() / ".ansible" / "collections" / "ansible_collections"
        )
        for namespace, collection in [i.split(".") for i in t.collections]:
            collection_path = (
                collection_root_dir
                / namespace
                / collection
            )
            config_path = collection_path / "meta" / "update_return_section.yml"
            module_path = collection_path / "plugins" / "modules" / (t.action + ".py")

            if not config_path.exists():
                self._display.display(f"no configuration file found at {config_path}, we won' update this collection.")
                continue

            if not module_path.exists():
                self._display.display(f"no module found at {module_path}")
                continue

            config = yaml.load(config_path.read_text())
            if not config.get("enabled"):
                self._display.display(f"update_return_section is disabled in {config_path}")
                continue


            result = {}
            for k, sample in r.items():
                k = str(k)
                if k.startswith("_"):
                    continue
                if k in ["changed", "invocation", "attempts"]:
                    continue

                if isinstance(sample, int):
                    _type = "int"
                elif isinstance(sample, str):
                    _type = "str"
                elif isinstance(sample, list):
                    _type = "list"
                elif isinstance(sample, dict):
                    _type = "dict"

                try:
                    description = config["keys"][k]["description"]
                except KeyError:
                    description = str(t.name)

                result[k] = {
                    "description": description,
                    "returned": "On success",
                    "type": _type,
                    "sample": ansible_unsafe_to_python(sample),
                }

            return_block = load_return_block(module_path)
            new_content = yaml.dump(result).split("\n")
            existing_content = return_block[str(t.name)]
            if len(new_content) > len(existing_content):
                self._display.display(f"the output of the last task is longer than the RETURN block of the module.")
            else:
                self._display.display(f"existing RETURN block is longer than the one collected")
                continue

            return_block = {str(t.name): new_content}
            self._display.display(f"updating {module_path}'s RETURN block.")
            write_return_block(module_path, return_block)
